
# 1、列表推导式与生成器的区别

**列表推导式**

	列表推导式会把for循环中的所有数据都加载到列表中，一旦数据量过大，则会占用很多内存。

```
>>> res = [s for s in range(10)
>>> print(res)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> len(res)
10
```

	迭代器可以进行多次迭代

```
#--- 迭代器可以多次迭代 ---#
res = [s for s in range(10)]
for i in res:
    print(i)
print('-'.center(30,'-'))
for i in res:
    print(i)
```

**生成器**

在python中，这种一边循环一边计算的机制，称为生成器：generator.<br />
生成器则是把列表推导式的[] 换成() ，此时会生成一个生成器对象。生成器对象的工作方式是边循环边生成，即每次处理一个对象

```
>>> gen = (g for g in range(10))
>>> print(gen)
<generator object <genexpr> at 0x0000017C62450D60>
>>> len(gen)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: object of type 'generator' has no len()
```

生成器时单迭代，只能迭代一次

```
#--- 生成器只能迭代一次 ---#
gen = (g  for g in range(10))
for i in gen:
    print(i)
print('-'.center(30, '-'))
for i in gen:       # 这次就不会进行迭代
    print(i)
```


# 2、元组用法

元组拆包

```
res = [(color,size) for color in colors for size in sizes]
for r in res:
    print(r) 
    print('%s:%s'%r) # 元组拆包
```

**collection.namedtuple** 使用

```
from  collections import namedtuple # collection.namedtuple 用来构建一个带字段名的元组和一个有名字的类

City = namedtuple('City','name addr age grade')
Jack = City('Beijing','jack','12',(2018,2))
print(Jack)		# City(name='Beijing', addr='jack', age='12', grade=(2018, 2))
print(Jack.age) # 12
```


# 3、列表中 “ * ” 与列表推导式之间的关系

我们看第一组例子，并判断其结果

```python
list1 = [['_'] * 3] * 3
list1[1][1] = 'x'
print(list1)
#-- 结果是哪个 --#
a.[['_', 'X', '_'], ['_', 'X', '_'], ['_', 'X', '_']]
b.[['_', '_', '_'], ['_', 'X', '_'], ['_', '_', '_']]
##-- 答案 --#
"""
答案是a。
上面的list1 就等于下面的for循环，把b的地址重复3次追加到l列表中，所以外层列表中一个地址指向了三个列表。
        b = ['_'] * 3
        l = []
        print(id(l))
        for i in range(3):
            l.append(b)
        print(id(l))
"""
```

我们来看第二组例子，并判断结果

```python
list2 = [['_']*3 for i in range(3)]
list2[1][1] = 'x'
print(list2)
#-- 结果是哪个 --#
a.[['_', 'X', '_'], ['_', 'X', '_'], ['_', 'X', '_']]
b.[['_', '_', '_'], ['_', 'X', '_'], ['_', '_', '_']]
##-- 答案 --#
"""
答案是b
上面的list2 等于下面的for循环，每次循环b就会创建一个新的地址，故外层列表有三个同的地址。
"""
```

**总结**

注意列表使用时，列表是否创建了新的地址。


# 4、collections 用法

- 
**namedtuple**
<br />**namedtuple**就是给一个tuple元素命名




# 5、setdefault()

给用户获取字典时设置默认值，防止没有取到值而报错。

**语法**

```python
dict.setdefault(key,default=None)

## 事例 ##
dic = {'user':'rion','age':15}
dic.setdefault('user',1)
'rion'

dic.setdefault('addr','beijing')
'beijing'

dic
{'user': 'rion', 'age': 15, 'addr': 'beijing'}
```

**注意：**

		get获取值如果不存在则会报错，但不会修改原字典中的值，而setdefault会修改原字典中的值，即不存在则添加进去


# 6、set 集合用法

- 交集、合集、差集

```python
# 交集
s1 = {1,2,3,4,5,'rion','jack','lucy'}
s2 = {4,5,'lucy','tom','jim'}
print(s1 & s2)  # 交集
{'lucy', 4, 5}
print(s1 | s2)  # 合集
{'rion', 1, 2, 3, 4, 5, 'jim', 'lucy', 'jack', 'tom'}
# 差集 谁写在前面就以谁为基础
print(s1 - s2)  # 差集
{'rion', 1, 2, 3, 'jack'}
print(s2 - s1)  # 差集
{'jim', 'tom'}
```

- 集合推导式

```
s = {n*2 for n in range(5)}
print(s)
{0, 2, 4, 6, 8}
```


# 7、列表、元组、集合、字典 速率测试

[概括几点列表、字典、集合某些操作的时间复杂度比较：

1.查找速度快,无论dict有10个元素还是10万个元素，查找速度都一样。而list的查找速度随着元素增加而逐渐下降。

不过dict的查找速度快不是没有代价的，dict的缺点是占用内存大，还会浪费很多内容，list正好相反，占用内存小，但是查找速度慢。

2.字典值可以没有限制地取任何python对象，既可以是标准的对象，也可以是用户定义的，但键不行。不允许同一个键出现两次。

键必须不可变，所以可以用数字，字符串或元组充当，所以用列表就不行。

3.关于列表内部实现是数组（具体实现要看解析器, CPython的实现 ），因此就有数组的特点。超过容量会增加更多的容量，set, get 是O(1)，但del, insert, in的性能是O(n)。具体的看下表，'n’是容器中当前的元素数， 'k’需要操作的元素个数；

关于字典需要了解的是hash函数和哈希桶。一个好的hash函数使到哈希桶中的值只有一个，若多个key hash到了同一个哈希桶中，称之为哈希冲突。查找值时，会先定位到哈希桶中，再遍历hash桶。更详细的信息请点这里。在hash基本没有冲突的情况下get, set, delete, in方面都是O(1)。自己的操作不会超过O(n)；

关于set内部实现是dict的。在in操作上是O(1), 这一点比list要强。

也有list不存在的差运算；

8、`__setattr__`  和 `__getattr__` 和 `__delattr__` 的区别

> 参考文章：[https://zhuanlan.zhihu.com/p/62569340](https://zhuanlan.zhihu.com/p/62569340)

