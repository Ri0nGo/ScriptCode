本文主要是一些工作中用到的轮子

# 1. 生成随机字符串
```python
import string
import random
def get_random_str(str_length=10):
  """
  生成一个指定长度的随机字符串
  """
  digits=string.digits
  ascii_letters=string.ascii_letters  # 含大小写字符
  str_list =[random.choice(digits +ascii_letters) for i in range(str_length)]
  random_str =''.join(str_list)
  return random_str
```

# 2. 常见加密类
```python
import hashlib
import base64
from functools import wraps

class Encrypt:
    
    def execute_status(func):  
        '''''异常处理装饰器，返回数据结构可以自定义'''  
        def inner(*args, **kwargs):  
            result, error = None, None
            try:
                result = func(*args, **kwargs)
            except Exception as e:
                error = str(e)
            return {'result': result, 'error':  error}
        return inner

    @execute_status
    def md5(original_str, salt=None):
        """
        使用原始字符串加盐生成md5
        :param original_str: 需要加密的字符串
        :param salt: 盐
        :return: 加密后的字符串
        """
        return hashlib.md5(original_str.encode("utf8")).hexdigest()

    @execute_status
    def sha256(original_str):
        return hashlib.sha256(original_str.encode("utf-8")).hexdigest()

    @execute_status
    def base64encode(original_str):
        """base64 编码"""
        return base64.b64encode(original_str.encode("utf-8")).decode("utf-8")
    
    @execute_status
    def base64decode(encrypt_str):
        """base64 解码"""
        return base64.b64decode(encrypt_str).decode("utf-8")
        
    @execute_status
    def base64Urlencode(original_str):
        """base64url编码，本质是把base64编码中的+ / = 符号变成其他符号"""
        return base64.urlsafe_b64encode(original_str.encode('utf-8')).decode("utf-8").rstrip('=')
    
    @execute_status
    def base64Urldecode(encrypt_str):
        padding = b'=' * (4 - (len(encrypt_str) % 4))  # 补齐末尾的“=”号
        return base64.urlsafe_b64decode(encrypt_str.encode('utf8') + padding).decode('utf8')
    
```

# 3. Redis 封装类
```python
import redis  
import settings

if hasattr(settings, 'REDIS_CONFIG'):
    class RedisDBConfig:
        HOST = settings.REDIS_CONFIG['HOST']
        PORT = settings.REDIS_CONFIG['PORT']
        DB = settings.REDIS_CONFIG['DB']
        PASSWORD = settings.REDIS_CONFIG['PASSWORD']

def operator_status(func):  
    '''''get operatoration status 
    '''  
    def gen_status(*args, **kwargs):  
        error, result = None, None
        try:
            result = func(*args, **kwargs)
        except Exception as e:
            error = str(e)
        return {'result': result, 'error':  error}
    return gen_status

class RedisCache(object):
    def __init__(self):
        if hasattr(settings, 'REDIS_CONFIG'):
            if not hasattr(RedisCache, 'pool'):
                RedisCache.create_pool()
            self._connection = redis.Redis(connection_pool = RedisCache.pool)

    @staticmethod
    def create_pool():
        RedisCache.pool = redis.ConnectionPool(
                host = RedisDBConfig.HOST,
                port = RedisDBConfig.PORT,
                db   = RedisDBConfig.DB,
                password = RedisDBConfig.PASSWORD)

    @operator_status
    def set(self, *args, **kwargs):
        '''''set data with (key, value)
        '''
        return self._connection.set(*args, **kwargs)

    @operator_status
    def mset(self, *args, **kwargs):
        '''''set data with (key, value)
        '''
        return self._connection.mset(*args, **kwargs)

    @operator_status
    def mget(self, *args):
        '''''set data with (key, value)
        '''
        return self._connection.mget(*args)

    @operator_status
    def get(self, key):
        '''''get data by key
        '''
        return self._connection.get(key)

    @operator_status
    def delete(self, key):
        '''''delete cache by key
        '''
        return self._connection.delete(key)

    @operator_status
    def setnx(self, *args, **kwargs):
        '''''delete cache by key
        '''
        return self._connection.setnx(*args, **kwargs)

    @operator_status
    def incr(self, *args, **kwargs):
        '''''delete cache by key
        '''
        return self._connection.incr(*args, **kwargs)

    @operator_status
    def sadd(self, key, value):
        '''''delete cache by key
        '''
        return self._connection.sadd(key, value)

    @operator_status
    def hset(self, key, field, value):
        '''''set cache by (key, field, value)
        '''
        return self._connection.hset(key, field, value)

    @operator_status
    def hget(self, key, field):
        '''''delete cache by (key, field)
        '''
        return self._connection.hget(key, field)

    @operator_status
    def hmset(self, key, dic):
        '''''set cache by (key, dict)
        '''
        return self._connection.hmset(key, dic)
    
    @operator_status
    def expire(self, key,expire_sec):
        '''''set expire time by (key,expire_sec)
        '''
        return self._connection.expire(key, expire_sec)
# redis_cache = RedisCache()
# redis_cache.set("x1","y1")
```

# 4. 数据类型转换
```python
import json
import pickle
class DataTypeChange:
    """
    json convert to string 
    string convert to byte
    """
    def json2str(self, data):
        return json.dumps(data)
    
    def str2json(self, data):
        return json.loads(data)

    def str2byte(self, data):
        return pickle.dumps(data)
    
    def byte2str(self, data):
        return pickle.loads(data)
```

# 5. 文件压缩和解压
```python
def build_zip(dir_name):
    # 创建缓存
    zip_buffer = io.BytesIO()
    zip = zipfile.ZipFile(zip_buffer,'a',zipfile.ZIP_DEFLATED)
    for root,dirs,files in os.walk(dir_name):
        # print(root,dirs,files)
        for file in files:
            # 若存在多级目录： ./data/userImage/uuid_XXXX/i_01.png
            uuid_path = os.path.join(root, file).split("userImage/")[1]
            # zip.write(文件路径，写入压缩包文件路径，压缩方式)
            # 若不写第二个参数，默认使用第一个参数作为第二个参数
            zip.write(os.path.join(root,file),uuid_path,compress_type = zipfile.ZIP_DEFLATED)
        if not files:
            uuid_path = os.path.join(root).split("userImage/")[1] + '\\'
            zif=zipfile.ZipInfo((uuid_path))
            zip.writestr(zif,"")

def zip_extractall(rcv_file):
    """
    压缩包提取
    rcv_file： 可以是字符串，也可以是 IO[bytes]
    """
    zip_file = zipfile.ZipFile(rcv_file, 'r')
    zip_file.extractall(tmp_fullpath)
```


